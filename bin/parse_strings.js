#!/usr/bin/nodejs
const fs = require('fs');
const path = require('path');

const inputIniPath = path.join(__dirname, '..', 'res', 'strings.ini');
const outputBinPath = path.join(__dirname, '..', 'res/out', 'strings.bin');
const outputHPath = path.join(__dirname, '..', 'res/out', 'strings_index.h');

/**
 * Processes raw string values from INI file.
 * Removes surrounding quotes and interprets escape sequences (\n, \r, \xNN).
 * @param {string} rawValue The raw string value from the INI file.
 * @returns {string} The processed string.
 */
function processStringValue(rawValue) {
	let value = rawValue.trim();
	// Remove surrounding quotes if present
	if (value.startsWith('"') && value.endsWith('"')) {
		value = value.substring(1, value.length - 1);
	}

	// Interpret escape sequences
	// Replace \\ first to avoid double replacement
	value = value.replace(/\\\\/g, '\u0000TEMP_BACKSLASH\u0000');
	// Replace standard C escapes
	value = value.replace(/\\n/g, '\n');
	value = value.replace(/\\r/g, '\r');
	value = value.replace(/\\t/g, '\t');
	value = value.replace(/\\"/g, '"');
	// Replace \xNN hex escapes
	value = value.replace(/\\x([0-9A-Fa-f]{2})/g, (match, hex) => {
		return String.fromCharCode(parseInt(hex, 16));
	});
	// Restore original backslashes
	value = value.replace(/\u0000TEMP_BACKSLASH\u0000/g, '\\');

	return value;
}

try {
	console.log(`Reading INI file: ${inputIniPath}`);
	const iniContent = fs.readFileSync(inputIniPath, 'utf-8');
	const lines = iniContent.split(/\r?\n/);

	const stringOffsets = new Map(); // Map<processedString, offset>
	const keyOffsets = new Map();    // Map<originalKey, offset>
	const uniqueStrings = [];        // Array<string>
	const offsetToKeys = new Map();  // Map<offset, originalKey[]>
	let currentOffset = 0;

	console.log('Processing strings...');
	for (const line of lines) {
		const trimmedLine = line.trim();
		// Ignore comments, empty lines, and section headers
		if (trimmedLine.startsWith(';') || trimmedLine === '' || trimmedLine.startsWith('[')) {
			continue;
		}

		const separatorIndex = trimmedLine.indexOf('=');
		if (separatorIndex === -1) {
			console.warn(`Skipping invalid line: ${line}`);
			continue;
		}

		const key = trimmedLine.substring(0, separatorIndex).trim();
		const rawValue = trimmedLine.substring(separatorIndex + 1).trim();

		// Handle comments after value
		const commentIndex = rawValue.indexOf(';');
		const finalRawValue = commentIndex !== -1 ? rawValue.substring(0, commentIndex).trim() : rawValue;

		if (!key) {
			console.warn(`Skipping line with empty key: ${line}`);
			continue;
		}

		const processedValue = processStringValue(finalRawValue);

		let offset;
		let isDuplicate = false;
		let firstKeyForOffset = null;

		if (stringOffsets.has(processedValue)) {
			// String already exists, use its offset
			offset = stringOffsets.get(processedValue);
			isDuplicate = true;
			// console.log(`  Duplicate found for key "${key}", using offset ${offset}`);
		} else {
			// New unique string
			offset = currentOffset;
			stringOffsets.set(processedValue, offset);
			uniqueStrings.push(processedValue);
			// Update offset for the next string (string length + null terminator)
			// Use Buffer.byteLength for accurate byte count
			currentOffset += Buffer.byteLength(processedValue, 'latin1') + 1;
			// console.log(`  New string for key "${key}", offset ${offset}`);
		}
		keyOffsets.set(key, offset);

		// Track keys per offset
		if (!offsetToKeys.has(offset)) {
			offsetToKeys.set(offset, []);
		}
		offsetToKeys.get(offset).push(key);
	}

	console.log(`Found ${uniqueStrings.length} unique strings.`);

	// Generate binary file
	console.log(`Generating binary file: ${outputBinPath}`);
	const buffers = uniqueStrings.map(str => Buffer.concat([
		Buffer.from(str, 'latin1'), // Use latin1 for 8-bit encoding
		Buffer.from([0]) // Null terminator
	]));
	const finalBuffer = Buffer.concat(buffers);
	fs.writeFileSync(outputBinPath, finalBuffer);
	console.log(`Binary file size: ${finalBuffer.length} bytes.`);

	// Generate header file
	console.log(`Generating header file: ${outputHPath}`);
	let hContent = `// File generated by bin/parse_strings.js script
// DO NOT EDIT MANUALLY

#ifndef STRINGS_INDEX_H_
#define STRINGS_INDEX_H_

#define STRINGS_BIN_SIZE ${finalBuffer.length}

/**
 * @brief Offsets for strings stored in strings.bin
 */

`;

	// Keep track of the first key encountered for each offset
	const firstKeyPerOffset = new Map();
	for (const [key, offset] of keyOffsets.entries()) {
		if (!firstKeyPerOffset.has(offset)) {
			firstKeyPerOffset.set(offset, key);
		}
	}

	// Iterate through keys in insertion order (order from INI file)
	for (const [key, offset] of keyOffsets.entries()) {
		hContent += `#define ${key} ${offset}`;
		const firstKey = firstKeyPerOffset.get(offset);
		if (key !== firstKey) {
			// This key's string is a duplicate of a previous one
			hContent += ` // Same as ${firstKey}`;
		}
		hContent += '\n';
	}

	hContent += `
#endif /* STRINGS_INDEX_H_ */
`;

	fs.writeFileSync(outputHPath, hContent, 'utf-8');
	console.log('Done.');

} catch (error) {
	console.error('Error processing strings:', error);
	process.exit(1);
}
